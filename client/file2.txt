當然可以。以下是一個使用Python的`http.server`模組來實現HTTPS檔案伺服器的範例，以及一個使用`requests`模組來上傳檔案的客戶端範例。

首先，這是伺服器端的程式碼：

```python
import http.server
import socketserver
import ssl

class MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    def do_POST(self):
        file_length = int(self.headers['Content-Length'])
        with open(self.path, 'wb') as output_file:
            output_file.write(self.rfile.read(file_length))
        self.send_response(200)
        self.end_headers()

def start_https_server(ip, port, certfile):
    httpd = socketserver.TCPServer((ip, port), MyHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket, 
                                   server_side=True, 
                                   certfile=certfile, 
                                   ssl_version=ssl.PROTOCOL_TLS)
    print(f"Serving at https://{ip}:{port}")
    httpd.serve_forever()

start_https_server('localhost', 4443, 'path/to/localhost.pem')
```

然後，這是客戶端的程式碼：

```python
import requests

def upload_files_to_server(url, file_paths):
    for file_path in file_paths:
        try:
            with open(file_path, 'rb') as file:
                response = requests.post(f"{url}/{file_path}", files={file_path: file}, verify='path/to/localhost.pem')
                if response.status_code == 200:
                    print(f"Uploaded file: {file_path}")
                else:
                    print(f"Failed to upload file: {file_path}. Server responded with status code: {response.status_code}")
        except Exception as e:
            print(f"An error occurred while uploading {file_path}: {str(e)}")

upload_files_to_server('https://localhost:4443', ['file1.txt', 'file2.txt'])
```

這個範例中，伺服器端會在收到POST請求時將收到的資料寫入到一個檔案中，檔案的名稱由URL的路徑部分決定。客戶端則會捕捉可能發生的錯誤，並在上傳失敗時輸出錯誤訊息。

請注意，這只是一個基本的範例，並未包含所有可能需要的功能。在實際使用時，您可能需要根據自己的需求來修改或擴充這些程式碼。例如，您可能需要添加認證機制以保護您的伺服器，或者使用更高級的傳輸協定（如HTTPS）來提供更穩定和安全的檔案傳輸服務。希望這對您有所幫助！